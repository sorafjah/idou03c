<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
  <title>åœ°å›³ç§»å‹•ï¼ˆä¿®æ­£ç‰ˆãƒ»é †åºä»˜ãé€šéï¼†ãƒ‡ãƒãƒƒã‚°ï¼‰</title>
  <!-- Tailwind CDNï¼ˆé–‹ç™ºå‘ã‘ï¼‰ã€‚æœ¬ç•ªã¯PostCSS/CLIæ¨å¥¨ -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <!-- 404å›é¿ç”¨ã®ãƒ‡ãƒ¼ã‚¿URLãƒ•ã‚¡ãƒ“ã‚³ãƒ³ -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Ctext y='14' font-size='14'%3E%F0%9F%97%BA%EF%B8%8F%3C/text%3E%3C/svg%3E">
  <!-- PWAã®manifestã¯æœªè¨­å®šï¼ˆã‚¢ã‚¤ã‚³ãƒ³404é˜²æ­¢ã®ãŸã‚ï¼‰ã€‚ç”¨æ„ã§ããŸã‚‰ä»¥ä¸‹ã‚’å¾©å¸°:
  <link rel="manifest" href="manifest.json">
  -->
  <meta name="theme-color" content="#ffffff">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
    body { font-family: 'Inter', system-ui, -apple-system, sans-serif; overscroll-behavior: none; touch-action: manipulation; }

    :root{
      /* ãã™ã¿æ°´è‰²ï¼ˆå£è‰²ï¼‰*/
      --muted-sky: #a7c7d9;
      --muted-sky-dark: #8fb4ca;
    }

    /* ã‚°ãƒªãƒƒãƒ‰ã‚»ãƒ«å…±é€š */
    .grid-cell { width: 100%; height: 100%; aspect-ratio: 1/1; display: flex; justify-content: center; align-items: center; font-size: 1.5rem; border: 1px solid #d1d5db; background:#f9fafb; position: relative; }
    .setting-grid-cell { width: 100%; aspect-ratio: 1/1; display: flex; justify-content:center; align-items:center; font-size:1.25rem; border:1px solid #e5e7eb; background:#f9fafb; cursor:pointer; }

    #player { font-size: 1.25rem; z-index: 10; }
    #player .player-icon { display:inline-block; transition: transform 0.2s ease-in-out; }

    /* ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ */
    .mode-btn { padding: .5rem 0.5rem; border: 1px solid #d1d5db; background:#f9fafb; color:#6b7280; font-size: 0.9rem; }
    .mode-btn.active{ background:#3b82f6; color:#fff; border-color:#3b82f6; }

    /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
    @keyframes ping-effect{0%{transform:scale(1);opacity:1}75%,100%{transform:scale(2);opacity:0}}
    @keyframes tada-effect{0%{transform:scale(1)}10%,20%{transform:scale(.9) rotate(-3deg)}30%,50%,70%,90%{transform:scale(1.1) rotate(3deg)}40%,60%,80%{transform:scale(1.1) rotate(-3deg)}100%{transform:scale(1)}}
    .effect-ping{position:absolute;inset:0;border-radius:50%;background:rgba(34,197,94,.5);animation:ping-effect 1s cubic-bezier(0,0,.2,1)}
    .effect-tada{animation:tada-effect 1s ease-in-out}

    /* è¨­å®šãƒ“ãƒ¥ãƒ¼ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼éè¡¨ç¤º */
    #settings-view { scrollbar-width: none; }
    #settings-view::-webkit-scrollbar { width:0; height:0; }

    /* ç›¸å¯¾æ–¹ä½ã‚³ãƒãƒ³ãƒ‰ã®å¼·èª¿è¡¨ç¤º */
    .cmd-relative { border: 2px solid #22d3ee; background-color: #ecfeff; color: #0e7490; font-weight: bold; }

    /* ã‚·ãƒ¼ã‚±ãƒ³ã‚¹è¡¨ç¤ºç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .cmd-item{ padding:0.15rem 0.4rem; border-radius:0.375rem; border:1px solid #e5e7eb; background:#f9fafb; font-size:1.1rem; }
    .cmd-done{ opacity:0.4; }
    .cmd-current{ border-color:#f97316; box-shadow:0 0 0 2px rgba(249,115,22,0.4); }
    .cmd-error{ border-color:#b91c1c; background:#fee2e2; color:#991b1b; }

    /* æ±è¥¿å—åŒ—ãƒ©ãƒ™ãƒ«ï¼ˆæ±è¥¿å—åŒ—ãƒ¢ãƒ¼ãƒ‰ã®ã¨ãã ã‘è¡¨ç¤ºï¼‰ */
    .cardinal-label { position:absolute; display:none; font-weight:600; color:#334155; }
    .mode-cardinal .cardinal-label { display:block; }
    .cardinal-n { top: -1.5rem; left: 50%; transform: translateX(-50%); }
    .cardinal-s { bottom: -1.5rem; left: 50%; transform: translateX(-50%); }
    .cardinal-e { right: -1.5rem; top: 50%; transform: translateY(-50%); }
    .cardinal-w { left: -1.5rem; top: 50%; transform: translateY(-50%); }

    /* å£ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆãã™ã¿æ°´è‰²ï¼‰ */
    .wall-cell { background-color: var(--muted-sky); }
    .setting-wall-cell { background-color: var(--muted-sky-dark); }

    /* å³ä¸Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯éè¡¨ç¤º */
    #message-area{ display:none; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen w-screen overflow-hidden">

  <!-- è¨­å®šãƒ“ãƒ¥ãƒ¼ -->
  <div id="settings-view" class="p-4 md:p-8 max-w-4xl mx-auto h-full overflow-y-auto">
    <h1 class="text-3xl font-bold mb-6 text-center text-blue-600">&nbsp;</h1>
    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
      <!-- å·¦ï¼šå…¥åŠ› -->
      <div class="space-y-6 bg-white p-6 rounded-lg shadow-md">
        <fieldset class="border p-4 rounded-lg">
          <legend class="text-lg font-medium px-2">ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º</legend>
          <div class="flex gap-4">
            <div>
              <label class="block text-md font-medium mb-2">è¡Œ</label>
              <input id="grid-rows" type="number" min="3" max="10" value="5" class="w-24 p-3 border rounded-lg text-lg" />
            </div>
            <div>
              <label class="block text-md font-medium mb-2">åˆ—</label>
              <input id="grid-cols" type="number" min="3" max="10" value="6" class="w-24 p-3 border rounded-lg text-lg" />
            </div>
          </div>
        </fieldset>
        <fieldset class="border p-4 rounded-lg">
          <legend class="text-lg font-medium px-2">ã‚¢ã‚¤ãƒ†ãƒ é¸æŠ</legend>
          <div id="item-selector" class="grid grid-cols-2 gap-3">
            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="item-type" value="start" checked><span class="text-lg text-green-600">ğŸ¤ ã‚¹ã‚¿ãƒ¼ãƒˆ</span></label>
            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="item-type" value="goal"><span class="text-lg">ğŸ  ã‚´ãƒ¼ãƒ«</span></label>

            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="item-type" value="wall"><span class="text-lg"><span class="inline-block w-5 h-5 rounded-sm align-middle" style="background: var(--muted-sky);"></span> å£</span></label>
            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="item-type" value="impassable"><span class="text-lg">ğŸ‘» é€šè¡Œä¸å¯</span></label>

            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="item-type" value="waypoint"><span class="text-lg">ğŸ” é€šéåœ°ç‚¹</span></label>
            <label class="flex items-center gap-2 cursor-pointer"><input type="radio" name="item-type" value="erase"><span class="text-lg">ğŸ—‘ï¸ æ¶ˆã—ã‚´ãƒ </span></label>
          </div>
          <p class="text-sm text-gray-600 mt-2">é€šéåœ°ç‚¹ã¯æœ€å¤§6å€‹ã€‚ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ã‚‚å¯ã€‚</p>
          <div class="mt-2 space-y-1 text-sm text-gray-700">
            <label class="flex items-center gap-2">
              <input id="use-waypoint-order" type="checkbox" class="rounded" />
              <span>é€šéé †ã‚ã‚Šï¼ˆç•ªå·è¡¨ç¤ºï¼‹é †ç•ªãƒã‚§ãƒƒã‚¯ï¼‰</span>
            </label>
          </div>
        </fieldset>
        <div class="space-y-3 pt-2">
          <button id="random-all-btn" class="w-full p-3 bg-green-500 text-white rounded-lg shadow">ğŸ² å…¨è¨­å®šãƒ©ãƒ³ãƒ€ãƒ </button>
          <button id="random-items-btn" class="w-full p-3 bg-green-500 text-white rounded-lg shadow">ğŸ” ã‚¢ã‚¤ãƒ†ãƒ ã®ã¿ãƒ©ãƒ³ãƒ€ãƒ </button>
          <button id="start-game-btn" class="w-full p-3 bg-blue-600 text-white rounded-lg shadow">ğŸš€ ã‚²ãƒ¼ãƒ é–‹å§‹</button>
        </div>
        <p id="settings-error" class="text-red-500 text-center h-6"></p>
      </div>
      <!-- å³ï¼šãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
      <div class="bg-white p-4 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold mb-4 text-center">é…ç½®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h2>
        <div id="setting-grid-container" class="grid bg-white border border-gray-300 rounded-lg overflow-hidden"></div>
      </div>
    </div>
  </div>

  <!-- ã‚²ãƒ¼ãƒ ãƒ“ãƒ¥ãƒ¼ -->
  <div id="game-view" class="hidden h-screen w-screen flex flex-col p-4">
    <div class="flex justify-between items-center mb-2 w-full max-w-7xl mx-auto flex-shrink-0">
      <span class="text-lg">&nbsp;</span>
      <div id="message-area" class="text-xl font-semibold text-green-600 h-8 text-right"></div>
    </div>

    <div class="flex-grow flex flex-col md:flex-row-reverse gap-4 w-full max-w-7xl mx-auto overflow-hidden">
      <!-- å³ï¼šã‚°ãƒªãƒƒãƒ‰ï¼ˆå¤§ï¼‰ -->
      <div class="flex-grow flex justify-center items-center md:w-3/5 h-full relative">
        <!-- æ±è¥¿å—åŒ—ãƒ©ãƒ™ãƒ«ç”¨ãƒ©ãƒƒãƒ‘ãƒ¼ -->
        <div id="grid-wrapper" class="relative">
          <span class="cardinal-label cardinal-n">åŒ—</span>
          <span class="cardinal-label cardinal-s">å—</span>
          <span class="cardinal-label cardinal-e">æ±</span>
          <span class="cardinal-label cardinal-w">è¥¿</span>
          <div id="grid-container" class="grid bg-white shadow-lg rounded-lg border border-gray-300"></div>
        </div>
      </div>
      <!-- å·¦ï¼šæ“ä½œï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰ -->
      <div class="flex flex-col md:w-2/5 space-y-3 h-full">
        <div class="bg-white p-3 rounded-lg shadow-md border flex-grow min-h-[320px] overflow-y-auto">
          <div id="sequence-display" class="flex flex-wrap gap-2 text-2xl items-start content-start"></div>
          <p id="debug-info" class="mt-2 text-sm text-red-600 min-h-[1.5rem]"></p>
        </div>
        <!-- ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ï¼ˆ3ã¤ï¼‰ -->
        <div class="flex rounded-md shadow-sm">
          <button id="mode-absolute-btn" class="mode-btn active w-1/3 rounded-l-md">çµ¶å¯¾æ–¹ä½</button>
          <button id="mode-cardinal-btn" class="mode-btn w-1/3 border-l-0 border-r-0">æ±è¥¿å—åŒ—</button>
          <button id="mode-relative-btn" class="mode-btn w-1/3 rounded-r-md">ç›¸å¯¾æ–¹ä½</button>
        </div>
        <div id="direction-pad" class="p-2 bg-white rounded-lg shadow-md h-[120px] flex justify-center items-center"></div>
        <div class="grid grid-cols-4 gap-2">
          <button id="undo-btn" class="p-2 bg-blue-500 text-white rounded-lg shadow text-sm">ã‚‚ã©ã™</button>
          <button id="reset-btn" class="p-2 bg-blue-500 text-white rounded-lg shadow text-sm">ã‚¯ãƒªã‚¢</button>
          <button id="step-btn" class="p-2 bg-indigo-500 text-white rounded-lg shadow text-sm">ä¸€æ‰‹é€²ã‚€</button>
          <button id="run-btn" class="p-2 bg-green-600 text-white rounded-lg shadow text-sm">å®Ÿè¡Œ</button>
        </div>
        <button id="back-to-settings-btn" class="text-gray-500 hover:underline text-center text-lg p-1">è¨­å®šã«æˆ»ã‚‹</button>
      </div>
    </div>
  </div>

  <script>
  // ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
  const clamp=(n,min,max)=>Math.max(min,Math.min(max,n));
  const rand=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const shuffle = (arr) => arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
  const delay=ms=>new Promise(res=>setTimeout(res,ms));

  document.addEventListener('DOMContentLoaded', () => {
    // DOMå–å¾—
    const settingsView = document.getElementById('settings-view');
    const gameView = document.getElementById('game-view');
    const gridRowsInput = document.getElementById('grid-rows');
    const gridColsInput = document.getElementById('grid-cols');
    const itemSelector = document.getElementById('item-selector');
    const settingGridContainer = document.getElementById('setting-grid-container');
    const randomAllBtn = document.getElementById('random-all-btn');
    const randomItemsBtn = document.getElementById('random-items-btn');
    const startGameBtn = document.getElementById('start-game-btn');
    const settingsError = document.getElementById('settings-error');
    const useWaypointOrderInput = document.getElementById('use-waypoint-order');

    const backToSettingsBtn = document.getElementById('back-to-settings-btn');
    const gridContainer = document.getElementById('grid-container');
    const gridWrapper = document.getElementById('grid-wrapper');
    const sequenceDisplay = document.getElementById('sequence-display');
    const directionPad = document.getElementById('direction-pad');
    const debugInfo = document.getElementById('debug-info');

    // ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³3ã¤
    const modeAbsoluteBtn = document.getElementById('mode-absolute-btn');
    const modeCardinalBtn = document.getElementById('mode-cardinal-btn');
    const modeRelativeBtn = document.getElementById('mode-relative-btn');

    const undoBtn = document.getElementById('undo-btn');
    const resetBtn = document.getElementById('reset-btn');
    const stepBtn = document.getElementById('step-btn');
    const runBtn = document.getElementById('run-btn');
    const messageArea = document.getElementById('message-area');

    // ---- éŸ³ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã®ã¿åˆæœŸåŒ–ï¼šiPadå¯¾å¿œï¼‰----
    let synth; let drum; let noise; let mono;
    async function initAudio(){
      try{
        if(!synth){
          if (Tone.context.state !== 'running') await Tone.start();
          synth=new Tone.Synth({ oscillator:{type:'triangle'}, envelope:{attack:0.01,decay:0.2,sustain:0,release:0.8} }).toDestination();
          mono=new Tone.MonoSynth({ oscillator:{type:'square'}, envelope:{attack:0.01,decay:0.3,sustain:0,release:1.2} }).toDestination();
          drum=new Tone.MembraneSynth({ pitchDecay:0.03, octaves:6, oscillator:{type:'sine'}, envelope:{attack:0.001,decay:0.4,sustain:0,release:0.1} }).toDestination();
          noise=new Tone.NoiseSynth({ volume:-10, envelope:{attack:0.001, decay:0.15, sustain:0} }).toDestination();
        }
      }catch(e){ console.warn('Audio init deferred:', e?.message); }
    }
    ['pointerdown','keydown','touchstart'].forEach(ev=>{
      window.addEventListener(ev, ()=>initAudio(), { once:true, passive:true });
    });

    function playTone(freqOrNote, dur){ if(synth) synth.triggerAttackRelease(freqOrNote,dur); }

    // âœ… ã‚´ãƒ¼ãƒ«æˆåŠŸéŸ³ï¼ˆæ˜ã‚‹ã‚ï¼‰
    function playSuccess(){
      if(!synth) return;
      const now = Tone.now();
      const notes = ['C5','E5','G5','C5'];
      notes.forEach((n,i)=>synth.triggerAttackRelease(n, 0.12, now + i*0.12));
    }

    // âœ… å¤±æ•—éŸ³ï¼šã€Œã¡ã‚ƒã‚‰ã‚Šã‚ã‚Šãƒ¼ã‚“â†“ã€ä½ã‚ãƒ»é•·ã‚ï¼ˆä¸‹é™ï¼‰
    function playFailLong(){
      if(!mono) return;
      const t = Tone.now();
      const seq = [ ['E3',0.25], ['D3',0.25], ['C3',0.35], ['A2',0.6] ];
      let acc = 0;
      seq.forEach(([n,d])=>{ mono.triggerAttackRelease(n, d, t+acc); acc += d*0.9; });
    }

    // âœ… ğŸ‘»ãƒ’ãƒƒãƒˆéŸ³ï¼šã€Œã©ã£ãƒ»ã©ã£ãƒ»ã©ãƒ¼ã¨ãƒ¼ã€3é€£ãƒ‰ãƒ©ãƒ ï¼‹ãƒã‚¤ã‚º å³çµ‚äº†
    function playGhostTriple(){
      if(!drum||!noise) return;
      const t = Tone.now();
      drum.triggerAttackRelease('C2','8n', t + 0.00); // ã©ã£
      drum.triggerAttackRelease('C2','8n', t + 0.28); // ã©ã£
      drum.triggerAttackRelease('A1','4n', t + 0.56); // ã©ãƒ¼ãƒ¼
      noise.triggerAttackRelease('16n', t + 0.60);    // ã¨ãƒ¼ï¼ˆãƒã‚¤ã‚ºæ·»ãˆï¼‰
    }

    // çŠ¶æ…‹
    const allWaypointIcons = ['ğŸ”','ğŸ','ğŸ°','ğŸ‰','ğŸ“','ğŸ‡','ğŸ¥','ğŸ','ğŸ•','ğŸ©','ğŸ¥','ğŸ—','â¤ï¸','ğŸ’š','ğŸ’›','ğŸ’™','ğŸ©µ'];
    let landmarks = shuffle(allWaypointIcons).slice(0,6);
    let iconIndex = 0;
    const pickNextIcon = () => landmarks[(iconIndex++) % landmarks.length];
    const resetIcons = () => { landmarks = shuffle(allWaypointIcons).slice(0,6); iconIndex = 0; };

    let gameConfig = { gridRows:5, gridCols:6, start:null, goal:null, waypoints:[], walls:[], impassables: [], waypointsCount:0, useWaypointOrder:false, showWaypointNumbers:false };
    let gameState = {
      player:{row:0,col:0,dir:'left'},
      sequence:[],
      collectedWaypoints:new Set(),
      collectedOrder:[],
      orderOk:true,
      isRunning:false,
      moveMode:'absolute',
      exploded:false,
      currentStepIndex:0,
      highlightIndex:-1,
      lastErrorIndex:-1
    };

    const playerElement = document.createElement('span');
    playerElement.id='player';
    playerElement.innerHTML='<span class="player-icon">ğŸ¤</span>';

    // è¨­å®šã‚°ãƒªãƒƒãƒ‰
    gridRowsInput.addEventListener('input', updateSettingGrid);
    gridColsInput.addEventListener('input', updateSettingGrid);

    function updateSettingGrid(){
      const rows = clamp(parseInt(gridRowsInput.value)||5,3,10);
      const cols = clamp(parseInt(gridColsInput.value)||6,3,10);
      gridRowsInput.value = rows; gridColsInput.value = cols;
      gameConfig.gridRows = rows; gameConfig.gridCols = cols;
      settingGridContainer.innerHTML='';
      settingGridContainer.style.gridTemplateColumns = `repeat(${cols}, minmax(0,1fr))`;
      if (gameConfig.start && (gameConfig.start.row>=rows||gameConfig.start.col>=cols)) gameConfig.start=null;
      if (gameConfig.goal && (gameConfig.goal.row>=rows||gameConfig.goal.col>=cols)) gameConfig.goal=null;
      gameConfig.waypoints = gameConfig.waypoints.filter(w=>w.row<rows&&w.col<cols);
      gameConfig.walls = gameConfig.walls.filter(w=>w.row<rows&&w.col<cols);
      gameConfig.impassables = gameConfig.impassables.filter(w=>w.row<rows&&w.col<cols);
      gameConfig.waypoints.forEach((wp,i)=>wp.icon=gameConfig.waypoints[i].icon ?? landmarks[i%landmarks.length]);
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
        const d=document.createElement('div');
        d.className='setting-grid-cell';
        d.dataset.row=r; d.dataset.col=c;
        d.addEventListener('click', onSettingCellClick);
        settingGridContainer.appendChild(d);
      }
      updateSettingGridUI();
    }

    function onSettingCellClick(e){
      const cell=e.target.closest('.setting-grid-cell'); if(!cell) return;
      const row=+cell.dataset.row, col=+cell.dataset.col; const coord={row,col};
      const sel=itemSelector.querySelector('input[name="item-type"]:checked').value;
      const isS=gameConfig.start && gameConfig.start.row===row && gameConfig.start.col===col;
      const isG=gameConfig.goal && gameConfig.goal.row===row && gameConfig.goal.col===col;
      const wpi=gameConfig.waypoints.findIndex(w=>w.row===row && w.col===col);
      const wli=gameConfig.walls.findIndex(w=>w.row===row && w.col===col);
      const ipi=gameConfig.impassables.findIndex(w=>w.row===row && w.col===col);
      if (sel!=='start' && isS) gameConfig.start=null;
      if (sel!=='goal' && isG) gameConfig.goal=null;
      if (sel!=='waypoint' && wpi>-1) gameConfig.waypoints.splice(wpi,1);
      if (sel!=='wall' && wli>-1) gameConfig.walls.splice(wli,1);
      if (sel!=='impassable' && ipi>-1) gameConfig.impassables.splice(ipi,1);
      switch(sel){
        case 'start': gameConfig.start=coord; break;
        case 'goal': gameConfig.goal=coord; break;
        case 'waypoint':
          if(wpi===-1){
            if(gameConfig.waypoints.length<6){
              const icon = pickNextIcon();
              gameConfig.waypoints.push({row,col,icon});
            } else {
              flashError('é€šéåœ°ç‚¹ã¯6å€‹ã¾ã§ã§ã™');
            }
          }
          break;
        case 'wall':
          if(wli===-1) gameConfig.walls.push(coord);
          break;
        case 'impassable':
          if(ipi===-1) gameConfig.impassables.push(coord);
          break;
        case 'erase':
          break;
      }
      gameConfig.waypoints.forEach((wp,i)=>wp.icon=gameConfig.waypoints[i].icon ?? landmarks[i%landmarks.length]);
      updateSettingGridUI();
    }

    const getSetCell=(r,c)=>settingGridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);

    function updateSettingGridUI(){
      const showNums = useWaypointOrderInput?.checked;
      settingGridContainer.querySelectorAll('.setting-grid-cell').forEach(c=>{
        c.textContent='';
        c.classList.remove('setting-wall-cell');
      });
      gameConfig.walls.forEach(w=>{
        const c=getSetCell(w.row,w.col);
        if(c) { c.classList.add('setting-wall-cell'); c.textContent=''; }
      });
      gameConfig.impassables.forEach(w=>{ const c=getSetCell(w.row,w.col); if(c) c.textContent='ğŸ‘»'; });
      gameConfig.waypoints.forEach((wp,idx)=>{ 
        const c=getSetCell(wp.row,wp.col); 
        if(c){
          const num = showNums ? String(idx+1) : '';
          c.textContent = wp.icon + num;
        }
      });
      if (gameConfig.goal){ const c=getSetCell(gameConfig.goal.row,gameConfig.goal.col); if(c) c.textContent='ğŸ '; }
      if (gameConfig.start){ const c=getSetCell(gameConfig.start.row,gameConfig.start.col); if(c) c.innerHTML='<span class="text-green-600">ğŸ¤</span>'; }
    }

    randomAllBtn.addEventListener('click', async ()=>{
      await initAudio();
      gameConfig.gridRows=rand(3,10);
      gameConfig.gridCols=rand(3,10);
      gridRowsInput.value=gameConfig.gridRows;
      gridColsInput.value=gameConfig.gridCols;
      gameConfig.waypointsCount=rand(0,6);
      resetIcons();
      randomizeItemPlacement();
      updateSettingGrid();
    });
    randomItemsBtn.addEventListener('click', async ()=>{
      await initAudio();
      gameConfig.gridRows=+gridRowsInput.value;
      gameConfig.gridCols=+gridColsInput.value;
      gameConfig.waypointsCount=gameConfig.waypoints.length;
      resetIcons();
      randomizeItemPlacement();
      updateSettingGridUI();
    });

    function randomizeItemPlacement(){
      const rows=gameConfig.gridRows, cols=gameConfig.gridCols, count=gameConfig.waypointsCount; const used=new Set();
      gameConfig.walls=[];
      gameConfig.impassables=[];
      gameConfig.start = randomEmpty(rows,cols,used);
      gameConfig.goal = randomEmpty(rows,cols,used);
      gameConfig.waypoints=[];
      for(let i=0;i<count;i++){
        const p=randomEmpty(rows,cols,used);
        gameConfig.waypoints.push({row:p.row,col:p.col,icon:pickNextIcon()});
      }
      // å£ã¨é€šè¡Œä¸å¯ã‚‚ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
      const maxBarriers = Math.max(0, Math.floor(rows*cols*0.2));
      const wallCount = rand(0, Math.floor(maxBarriers/2));
      const impCount = rand(0, Math.floor(maxBarriers/2));
      for(let i=0;i<wallCount;i++){
        gameConfig.walls.push(randomEmpty(rows,cols,used));
      }
      for(let i=0;i<impCount;i++){
        gameConfig.impassables.push(randomEmpty(rows,cols,used));
      }
    }

    startGameBtn.addEventListener('click', async ()=>{
      await initAudio();
      gameConfig.useWaypointOrder = useWaypointOrderInput?.checked ?? false;
      gameConfig.showWaypointNumbers = gameConfig.useWaypointOrder;
      if(parseSettings()) showGameView();
    });

    function parseSettings(){
      settingsError.textContent='';
      gameConfig.gridRows=+gridRowsInput.value;
      gameConfig.gridCols=+gridColsInput.value;
      gameConfig.waypointsCount=gameConfig.waypoints.length;
      try{
        if(!gameConfig.start) throw new Error('ã‚¹ã‚¿ãƒ¼ãƒˆã‚’é…ç½®ã—ã¦ãã ã•ã„');
        if(!gameConfig.goal) throw new Error('ã‚´ãƒ¼ãƒ«ã‚’é…ç½®ã—ã¦ãã ã•ã„');
        const all=[gameConfig.start,gameConfig.goal,...gameConfig.waypoints,...gameConfig.walls, ...gameConfig.impassables];
        const set=new Set();
        for(const a of all){
          const s=`${a.row},${a.col}`;
          if(set.has(s)) throw new Error('é…ç½®ãŒé‡è¤‡ã—ã¦ã„ã¾ã™');
          set.add(s);
        }
        return true;
      }catch(e){
        settingsError.textContent=e.message;
        return false;
      }
    }

    // ã‚²ãƒ¼ãƒ ãƒ“ãƒ¥ãƒ¼
    backToSettingsBtn.addEventListener('click', showSettingsView);
    modeAbsoluteBtn.addEventListener('click',()=>setMoveMode('absolute'));
    modeCardinalBtn.addEventListener('click',()=>setMoveMode('cardinal'));
    modeRelativeBtn.addEventListener('click',()=>setMoveMode('relative'));

    function clearDebug(){
      if(debugInfo) debugInfo.textContent='';
      gameState.lastErrorIndex = -1;
    }

    function setMoveMode(mode){
      gameState.moveMode=mode; 
      gameState.sequence=[]; 
      gameState.currentStepIndex=0;
      gameState.highlightIndex=-1;
      clearDebug();
      updateSequenceDisplay(); 
      resetPlayer();

      [modeAbsoluteBtn, modeCardinalBtn, modeRelativeBtn].forEach(b => b.classList.remove('active'));
      if(mode==='absolute') modeAbsoluteBtn.classList.add('active');
      else if(mode==='cardinal') modeCardinalBtn.classList.add('active');
      else modeRelativeBtn.classList.add('active');

      // æ±è¥¿å—åŒ—ãƒ©ãƒ™ãƒ«ã®è¡¨ç¤ºåˆ¶å¾¡ï¼ˆæ±è¥¿å—åŒ—ãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰
      if(mode==='cardinal') gridWrapper.classList.add('mode-cardinal');
      else gridWrapper.classList.remove('mode-cardinal');

      // æ–¹å‘ãƒœã‚¿ãƒ³
      if(mode==='absolute' || mode==='cardinal'){
        const labels = (mode==='absolute')
          ? {up:'â¬†ï¸', left:'â¬…ï¸', right:'â¡ï¸', down:'â¬‡ï¸'}
          : {up:'åŒ—', left:'è¥¿', right:'æ±', down:'å—'};

        directionPad.innerHTML=`<div class="grid grid-cols-3 grid-rows-3 gap-1 w-full h-full place-items-center">
          <div class="col-start-2 row-start-1"><button data-action="up" class="dir-btn p-2 text-2xl font-bold w-full h-full flex items-center justify-center rounded-lg">${labels.up}</button></div>
          <div class="col-start-1 row-start-2"><button data-action="left" class="dir-btn p-2 text-2xl font-bold w-full h-full flex items-center justify-center rounded-lg">${labels.left}</button></div>
          <div class="col-start-3 row-start-2"><button data-action="right" class="dir-btn p-2 text-2xl font-bold w-full h-full flex items-center justify-center rounded-lg">${labels.right}</button></div>
          <div class="col-start-2 row-start-3"><button data-action="down" class="dir-btn p-2 text-2xl font-bold w-full h-full flex items-center justify-center rounded-lg">${labels.down}</button></div>
        </div>`;
      } else {
        // ç›¸å¯¾æ–¹ä½
        directionPad.innerHTML=`<div class="grid grid-cols-3 gap-2 w-full h-full items-center">
          <button data-action="turnLeft" class="dir-btn px-3 py-2 border rounded font-bold text-gray-700 bg-gray-50">å·¦ã«90Â°</button>
          <button data-action="forward" class="dir-btn px-3 py-2 border rounded font-bold text-gray-700 bg-gray-50">å‰é€²ã™ã‚‹</button>
          <button data-action="turnRight" class="dir-btn px-3 py-2 border rounded font-bold text-gray-700 bg-gray-50">å³ã«90Â°</button>
        </div>`;
      }
      addDirListeners();
    }

    function addDirListeners(){
      directionPad.querySelectorAll('.dir-btn').forEach(btn=>{
        btn.addEventListener('click',async ()=>{
          await initAudio();
          if(gameState.isRunning) return;
          const a=btn.dataset.action;
          gameState.sequence.push(a);
          gameState.currentStepIndex=0;
          gameState.highlightIndex=-1;
          clearDebug();
          updateSequenceDisplay();
        });
      });
    }

    undoBtn.addEventListener('click',async ()=>{
      await initAudio();
      if(gameState.isRunning) return;
      gameState.sequence.pop();
      gameState.currentStepIndex=0;
      gameState.highlightIndex=-1;
      clearDebug();
      updateSequenceDisplay();
    });
    resetBtn.addEventListener('click', async ()=>{
      await initAudio();
      if(gameState.isRunning) return;
      gameState.sequence=[];
      gameState.currentStepIndex=0;
      gameState.highlightIndex=-1;
      clearDebug();
      updateSequenceDisplay();
      generateMap();
      resetPlayer();
    });

    stepBtn.addEventListener('click', async ()=>{
      await initAudio();
      if(gameState.isRunning || gameState.sequence.length===0) return;
      if(gameState.currentStepIndex >= gameState.sequence.length) return;
      gameState.isRunning=true; setDisabled(true);
      gameState.exploded=false;
      const action = gameState.sequence[gameState.currentStepIndex];
      gameState.highlightIndex = gameState.currentStepIndex;
      updateSequenceDisplay();
      const ok = await runOneStep(action, gameState.currentStepIndex);
      if(ok){
        gameState.currentStepIndex++;
        checkGoal();
      }
      gameState.isRunning=false; setDisabled(false);
      gameState.highlightIndex=-1;
      updateSequenceDisplay();
    });
    runBtn.addEventListener('click', async ()=>{
      await initAudio();
      if(gameState.isRunning||gameState.sequence.length===0) return;
      gameState.currentStepIndex=0;
      clearDebug();
      await runSequence();
    });

    function showSettingsView(){
      gameView.classList.add('hidden');
      settingsView.classList.remove('hidden');
      gameState.sequence=[];
      gameState.currentStepIndex=0;
      gameState.highlightIndex=-1;
      clearDebug();
      updateSequenceDisplay();
      setMoveMode('absolute');
    }
    function showGameView(){
      settingsView.classList.add('hidden');
      gameView.classList.remove('hidden');
      generateMap();
      resetPlayer();
      clearDebug();
      setMoveMode('absolute');
    }

    function generateMap(){
      gridContainer.innerHTML='';
      gridContainer.style.gridTemplateColumns=`repeat(${gameConfig.gridCols}, minmax(0,1fr))`;
      const parent=gridContainer.parentElement.parentElement; // ãƒ©ãƒƒãƒ‘ãƒ¼ã®è¦ª
      const cw=parent.clientWidth-40; // ãƒ©ãƒ™ãƒ«åˆ†ã®ä½™ç™½
      const ch=parent.clientHeight-40;
      const size=Math.min(cw/gameConfig.gridCols, ch/gameConfig.gridRows);
      gridContainer.style.width=`${size*gameConfig.gridCols}px`;
      gridContainer.style.height=`${size*gameConfig.gridRows}px`;

      // ãƒ©ãƒƒãƒ‘ãƒ¼ã‚µã‚¤ã‚ºèª¿æ•´
      gridWrapper.style.width = gridContainer.style.width;
      gridWrapper.style.height = gridContainer.style.height;

      const font=size*0.4; playerElement.style.fontSize=`${font*0.8}px`;
      for(let r=0;r<gameConfig.gridRows;r++) for(let c=0;c<gameConfig.gridCols;c++){
        const cell=document.createElement('div');
        cell.id=`cell-${r}-${c}`;
        cell.className='grid-cell';
        cell.style.fontSize=`${font}px`;
        if (gameConfig.walls.some(w=>w.row===r&&w.col===c)) {
          cell.classList.add('wall-cell');
          cell.textContent='';
        }
        else if (gameConfig.impassables.some(w=>w.row===r&&w.col===c)) cell.textContent='ğŸ‘»';
        else if (gameConfig.goal && gameConfig.goal.row===r && gameConfig.goal.col===c) cell.textContent='ğŸ ';
        else {
          const wpIndex = gameConfig.waypoints.findIndex(w=>w.row===r&&w.col===c);
          if(wpIndex>-1){
            const wp = gameConfig.waypoints[wpIndex];
            const num = gameConfig.showWaypointNumbers ? String(wpIndex+1) : '';
            cell.textContent = wp.icon + num;
          }
        }
        gridContainer.appendChild(cell);
      }
    }

    function resetPlayer(){
      if(!gameConfig.start) return;
      gameState.player.row=gameConfig.start.row;
      gameState.player.col=gameConfig.start.col;
      changeDirection('left');
      gameState.collectedWaypoints.clear();
      gameState.collectedOrder = [];
      gameState.orderOk = true;
      gameState.currentStepIndex = 0;
      gameState.highlightIndex = -1;
      gameState.lastErrorIndex = -1;
      clearDebug();
      const s=document.getElementById(`cell-${gameConfig.start.row}-${gameConfig.start.col}`);
      if(s){ playerElement.remove(); s.appendChild(playerElement);}    }

    async function runSequence(){
      gameState.isRunning=true; setDisabled(true);
      gameState.exploded=false;
      resetPlayer();
      gameState.currentStepIndex=0;
      gameState.highlightIndex=-1;
      clearDebug();
      await delay(200);
      while(gameState.currentStepIndex < gameState.sequence.length){
        const action = gameState.sequence[gameState.currentStepIndex];
        gameState.highlightIndex = gameState.currentStepIndex;
        updateSequenceDisplay();
        const ok = await runOneStep(action, gameState.currentStepIndex);
        if(!ok) break;
        gameState.currentStepIndex++;
        await delay(500);
      }
      gameState.highlightIndex=-1;
      updateSequenceDisplay();
      if(!gameState.exploded){
        const atGoal = (gameState.player.row===gameConfig.goal.row && gameState.player.col===gameConfig.goal.col);
        const collectedAll = (gameState.collectedWaypoints.size===gameConfig.waypoints.length);
        const orderOK = !gameConfig.useWaypointOrder || gameState.orderOk;
        if(atGoal && collectedAll && orderOK){
          playSuccess();
          const goal=document.getElementById(`cell-${gameConfig.goal.row}-${gameConfig.goal.col}`);
          if(goal){ goal.classList.add('effect-tada'); setTimeout(()=>goal.classList.remove('effect-tada'),1000); }
        }else{
          playFailLong();
        }
      }
      gameState.isRunning=false; setDisabled(false);
    }

    function markError(stepIndex, reason, r, c){
      gameState.lastErrorIndex = stepIndex;
      if(debugInfo){
        let pos = '';
        if(typeof r === 'number' && typeof c === 'number'){
          pos = `ï¼ˆè¡Œ${r+1}, åˆ—${c+1}ï¼‰`;
        }
        debugInfo.textContent = `${reason}${pos}`;
      }
      updateSequenceDisplay();
    }

    async function runOneStep(action, stepIndex){
      if(!action) return false;
      let nr=gameState.player.row, nc=gameState.player.col; let moved=false;

      if (gameState.moveMode==='absolute' || gameState.moveMode==='cardinal'){
        changeDirection(action);
        if(action==='up') nr--; else if(action==='down') nr++; else if(action==='left') nc--; else if(action==='right') nc++;
        moved=true;
      } else {
        const cur=gameState.player.dir;
        if(action==='forward'){
          changeDirection(cur);
          if(cur==='up') nr--; else if(cur==='down') nr++; else if(cur==='left') nc--; else if(cur==='right') nc++;
          moved=true;
        }
        else if(action==='turnRight'){ const map={up:'right', right:'down', down:'left', left:'up'}; changeDirection(map[cur]); }
        else if(action==='turnLeft'){ const map={up:'left', left:'down', down:'right', right:'up'}; changeDirection(map[cur]); }
      }

      if(moved){
        // æ å¤–ã¨å£ã¯é€²ã‚ãªã„
        if(nr<0||nr>=gameConfig.gridRows||nc<0||nc>=gameConfig.gridCols){
          markError(stepIndex, 'æ å¤–ã«å‡ºã¾ã—ãŸ', nr, nc);
          return false;
        }
        if(gameConfig.walls.some(w=>w.row===nr&&w.col===nc)){
          markError(stepIndex, 'å£ã«ã¶ã¤ã‹ã‚Šã¾ã—ãŸ', nr, nc);
          return false;
        }

        // é€²è¡Œç¢ºå®š
        gameState.player.row=nr; gameState.player.col=nc;
        const cell=document.getElementById(`cell-${nr}-${nc}`); if(cell) cell.appendChild(playerElement);

        // ğŸ‘» ã«åˆ°ç€ã—ãŸã‚‰3é€£ãƒ‰ãƒ©ãƒ ï¼‹ãƒã‚¤ã‚ºã§å³çµ‚äº†
        if(gameConfig.impassables.some(w=>w.row===nr&&w.col===nc)){
          gameState.exploded = true;
          markError(stepIndex, 'ğŸ‘» ã«ã¶ã¤ã‹ã‚Šã¾ã—ãŸ', nr, nc);
          playGhostTriple();
          return false;
        }

        // ã‚¦ã‚§ã‚¤ãƒã‚¤ãƒ³ãƒˆå–å¾—ï¼ˆé †åºãƒã‚§ãƒƒã‚¯ã‚ã‚Šï¼‰
        const wpIndex = gameConfig.waypoints.findIndex(w=>w.row===nr && w.col===nc);
        if(wpIndex > -1){
          const key=`${nr},${nc}`;
          if(!gameState.collectedWaypoints.has(key)){
            gameState.collectedWaypoints.add(key);
            const order = wpIndex + 1;
            gameState.collectedOrder.push(order);
            if(gameConfig.useWaypointOrder){
              const expected = gameState.collectedOrder.length;
              if(order !== expected) gameState.orderOk = false;
            }
            playTone(440,0.08);
            const effect=document.createElement('div');
            effect.className='effect-ping';
            if(cell){
              const p=cell.querySelector('#player');
              p?cell.insertBefore(effect,p):cell.appendChild(effect);
              setTimeout(()=>effect.remove(),1000);
            }
            Array.from(cell.childNodes)
              .filter(n => n.nodeType === Node.TEXT_NODE && n.textContent.trim() !== '')
              .forEach(n => n.textContent = '');
          }
        }
      }
      return true;
    }

    function changeDirection(dir){
      gameState.player.dir=dir;
      const icon = playerElement.querySelector('.player-icon');
      if(!icon) return;
      let transform = '';
      if(dir==='left') transform = 'rotate(0deg) scaleX(1)';
      else if(dir==='right') transform = 'rotate(0deg) scaleX(-1)';
      else if(dir==='up') transform = 'rotate(90deg)';
      else if(dir==='down') transform = 'rotate(-90deg)';
      icon.style.transform = transform;
    }

    function checkGoal(){
      const atGoal = gameState.player.row===gameConfig.goal.row && gameState.player.col===gameConfig.goal.col;
      const all = gameState.collectedWaypoints.size===gameConfig.waypoints.length;
      const orderOK = !gameConfig.useWaypointOrder || gameState.orderOk;
      if(atGoal && all && orderOK){
        const goal=document.getElementById(`cell-${gameConfig.goal.row}-${gameConfig.goal.col}`);
        if(goal){ goal.classList.add('effect-tada'); setTimeout(()=>goal.classList.remove('effect-tada'),1000); }
        playSuccess();
      }
    }

    function updateSequenceDisplay(){
      const mode = gameState.moveMode;
      let map;
      if(mode === 'cardinal'){
        map={ up:'åŒ—', down:'å—', left:'è¥¿', right:'æ±' };
      } else if (mode === 'relative'){
        map={ forward:'å‰', turnLeft:'å·¦', turnRight:'å³' };
      } else {
        map={ up:'â¬†ï¸', down:'â¬‡ï¸', left:'â¬…ï¸', right:'â¡ï¸' };
      }
      sequenceDisplay.innerHTML = gameState.sequence.map((a,i)=>{
        let classes = ['cmd-item'];
        if(mode === 'cardinal' || mode === 'relative') classes.push('cmd-relative');
        if(i < gameState.currentStepIndex) classes.push('cmd-done');
        if(i === gameState.highlightIndex) classes.push('cmd-current');
        if(i === gameState.lastErrorIndex) classes.push('cmd-error');
        const label = map[a] || a;
        return `<span class="${classes.join(' ')}" data-index="${i}">${label}</span>`;
      }).join('');
    }

    function setDisabled(dis){
      [undoBtn,resetBtn,runBtn,stepBtn,modeAbsoluteBtn,modeCardinalBtn,modeRelativeBtn].forEach(b=>{
        b.disabled=dis; b.classList.toggle('opacity-50',dis);
      });
      directionPad.querySelectorAll('.dir-btn').forEach(b=>b.disabled=dis);
    }

    function randomEmpty(rows,cols,used){ let r,c,s; do{ r=rand(0,rows-1); c=rand(0,cols-1); s=`${r},${c}`; }while(used.has(s)); used.add(s); return {row:r,col:c}; }

    function flashError(msg){ settingsError.textContent=msg; setTimeout(()=>settingsError.textContent='',1800); }
    function toast(msg){} // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸éè¡¨ç¤ºä»•æ§˜ã®ãŸã‚ç©ºå®Ÿè£…

    function runSelfTests(){
      try{
        console.assert(gameState.player.dir === 'left', 'åˆæœŸå‘ãã¯leftã®ã¯ãš');
        console.assert(Array.isArray(gameState.sequence), 'sequence ã¯é…åˆ—ã®ã¯ãš');
        console.assert(gameConfig.gridRows >= 3 && gameConfig.gridCols >= 3, 'ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã¯3ä»¥ä¸Šã®ã¯ãš');
      }catch(e){
        console.warn('self test error', e);
      }
    }

    // Service Workerã¯æœªç™»éŒ²ï¼ˆã‚¢ã‚¤ã‚³ãƒ³404æŠ‘æ­¢ã®ãŸã‚ï¼‰ã€‚ç”¨æ„ã§ããŸã‚‰å¾©å¸°:
    // if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js').catch(()=>{}); }

    // åˆæœŸï¼ˆ5Ã—6å›ºå®šï¼‰
    updateSettingGrid();
    setMoveMode('absolute');
    runSelfTests();

    // iPadã®æ‹¡å¤§é˜²æ­¢ï¼ˆãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ï¼ãƒ”ãƒ³ãƒï¼‰
    document.addEventListener('dblclick', e => e.preventDefault(), { passive:false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
      const now = Date.now();
      if(now - lastTouchEnd <= 300){ e.preventDefault(); }
      lastTouchEnd = now;
    }, { passive:false });
    document.addEventListener('gesturestart', e => e.preventDefault());
  });
  </script>
</body>
</html>
